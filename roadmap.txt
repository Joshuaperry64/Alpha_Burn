# Project Roadmap: AlphaBurn Redesigned

## 1. Vision Statement

To evolve AlphaBurn into a modern, cross-platform, and highly intuitive media management suite. The application will provide a seamless experience for acquiring, organizing, and enjoying digital music, complemented by a powerful AI assistant that makes complex tasks simple. The redesign will prioritize stability, maintainability, and a superior user experience, while retaining the spirit of the original application.

## 2. Redesign Goals

- **Architectural Soundness:** Refactor the monolithic codebase into a modular architecture (e.g., Model-View-Controller) to improve code quality, testability, and ease of future development.
- **Modern & Intuitive UX:** Design a new user interface that is clean, visually appealing, and user-friendly for both novice and advanced users.
- **Cross-Platform Parity:** Abstract all platform-specific code (especially for hardware interactions like CD burning) to provide a consistent and reliable experience on Windows, macOS, and Linux.
- **Enhanced Functionality:** Improve core features, such as integrating directly with YouTube Music for higher-quality downloads and expanding CD burning capabilities.
- **Intelligent Assistance:** Deepen the integration of the AI assistant, empowering it to perform more complex, multi-step actions and provide proactive help.
- **Free-Tier Integrations:** All external services (APIs, cloud storage) must have a viable free tier to ensure the application remains accessible to all users.

## 3. Proposed Technology Stack

- **Language:** Python 3.10+
- **UI Framework:** PySide6 (provides official Python bindings for Qt and is generally more friendly to open-source projects).
- **Database ORM:** SQLAlchemy 2.0 (for robust, async-ready database interactions).
- **Database:** SQLite (for local library), with the option to connect to a free-tier cloud DB like Neon (Postgres) for sync.
- **Packaging:** PyInstaller or cx_Freeze for creating cross-platform executables.
- **Linting & Formatting:** Black and Ruff for maintaining code quality.

---

## 4. Project Phases & Tasks

### Phase 1: Core Backend and Foundation (Weeks 1-3)

*Goal: Build a solid, scalable foundation for the application.*

- **Task 1.1: Project Scaffolding**
  - [ ] Set up a new Git repository.
  - [ ] Create a modern project structure (e.g., `src/alphaburn`, `tests/`, `docs/`).
  - [ ] Configure development tools: `pyproject.toml` with `ruff`, `black`, `pytest`.
- **Task 1.2: Architectural Design (MVC)**
  - [ ] **Model:** Design the database schema using SQLAlchemy Core.
    - Tables: `songs`, `playlists`, `settings`.
  - [ ] **View:** Define the basic structure of the UI components (placeholders, no logic yet).
  - [ ] **Controller:** Create service classes that will contain the business logic.
    - `LibraryService`: Manages adding, removing, and querying songs.
    - `SettingsService`: Manages application configuration.
- **Task 1.3: Database Implementation**
  - [ ] Implement the `DatabaseManager` class to handle connections and sessions.
  - [ ] Write initial Alembic migrations for the schema.
- **Task 1.4: Basic Library UI**
  - [ ] Implement a non-functional main window.
  - [ ] Implement the library table view, populated with dummy data from the `LibraryService`.
  - [ ] Implement library scanning logic to populate the database from the local music folder.

### Phase 2: Media Playback and Downloading (Weeks 4-6)

*Goal: Re-implement and enhance the media playback and downloading features.*

- **Task 2.1: Audio Player**
  - [ ] Integrate the `QMediaPlayer` into the new UI.
  - [ ] Connect UI controls (play, pause, stop, volume, seek bar) to the player via the controller.
- **Task 2.2: Download Manager**
  - [ ] Create a `DownloadService` to handle the download queue and worker threads.
  - [ ] **Suggestion:** Replace generic `yt-dlp` with `ytmusicapi`. This will allow for more targeted searches, better metadata, and access to higher-quality audio from YouTube Music.
  - [ ] Implement the download worker to use `ytmusicapi` to find and download a track.
  - [ ] Implement the Spotify playlist integration: fetch playlist tracks using the Spotify API, then find and download each track using the `DownloadService`.
- **Task 2.3: Metadata Tagger**
  - [ ] Create a `TaggerService` that uses `mutagen` to apply metadata (title, artist, album, cover art) to downloaded files.
  - [ ] Integrate the `TaggerService` into the download completion process.
- **Task 2.4: UI Integration**
  - [ ] Build the UI for the downloader, showing the queue, progress, and status.
  - [ ] Connect the URL input field and download button to the `DownloadService`.

### Phase 3: CD/DVD Operations (Weeks 7-8)

*Goal: Create a robust, cross-platform module for disc operations.*

- **Task 3.1: Hardware Abstraction Layer**
  - [ ] Design a `DiscDevice` interface with methods like `eject()`, `get_info()`, `wipe()`, `burn()`.
  - [ ] Create concrete implementations for each OS:
    - `WindowsDiscDevice`: Use `ctypes` or PowerShell commands.
    - `LinuxDiscDevice`: Use command-line tools like `wodim`, `eject`.
    - `MacosDiscDevice`: Use `drutil` commands.
- **Task 3.2: Burning Service**
  - [ ] Create a `BurnService` to manage the burning process.
  - [ ] Use a library like `pycdlib` to create ISO 9660 images in a background thread.
  - [ ] The `BurnService` will use the `DiscDevice` interface to burn the generated ISO to the disc.
- **Task 3.3: UI Integration**
  - [ ] Build the UI for the burn queue, drive selection, and capacity meter.
  - [ ] Connect the UI to the `BurnService` and `DiscDevice` services.
  - [ ] Implement drag-and-drop from the library to the burn queue.

### Phase 4: AI Integration & UX Refinement (Weeks 9-10)

*Goal: Integrate the AI assistant and polish the overall user experience.*

- **Task 4.1: AI Assistant Service**
  - [ ] Create a `GeminiService` to encapsulate all interactions with the Google Gemini API.
  - [ ] Implement methods for sending prompts, managing chat history, and handling system instructions.
- **Task 4.2: Function Calling**
  - [ ] **Suggestion:** Enhance the AI by using Gemini's "Function Calling" feature.
  - [ ] Define functions the AI can call, e.g., `find_and_download_playlist(genre: str)`, `get_cd_status()`, `add_song_to_burn_queue(song_title: str)`.
  - [ ] This will allow users to give natural language commands like "Download a 90s rock playlist" or "Add the new song to the CD and burn it."
- **Task 4.3: UI Integration**
  - [ ] Build a modern, chat-bubble style interface for the AI assistant.
  - [ ] Connect the chat UI to the `GeminiService`.
- **Task 4.4: General UX Polish**
  - [ ] Finalize themes, icons, and animations.
  - [ ] Ensure the application is fully responsive and accessible.
  - [ ] Add a first-run setup wizard for configuring paths and API keys.

### Phase 5: Cloud Sync & Distribution (Weeks 11-12)

*Goal: Add optional cloud features and package the application for release.*

- **Task 5.1: Cloud Sync (Optional Feature)**
  - [ ] **Suggestion:** Implement an optional service for synchronizing the library database and presets.
  - [ ] Research free-tier cloud database providers (e.g., Neon, Supabase, Turso).
  - [ ] Add logic to the `DatabaseManager` to connect to a remote DB if configured.
  - [ ] Add UI for users to log in and manage sync settings.
- **Task 5.2: Packaging**
  - [ ] Create build scripts using PyInstaller for Windows and macOS.
  - [ ] Create a build script for a Linux AppImage or Flatpak.
- **Task 5.3: Documentation & Release**
  - [ ] Write user documentation (README, website).
  - [ ] Create a project website/landing page (e.g., using GitHub Pages).
  - [ ] Draft the first release notes and publish the builds.
